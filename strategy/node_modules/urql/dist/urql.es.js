import { createRequest as e } from "@urql/core";

export * from "@urql/core";

import * as r from "react";

import { createContext as t, useContext as n, useRef as a, useState as u, useCallback as i, useEffect as o, useMemo as s } from "react";

import { toPromise as c, take as v, filter as f, onPush as d, subscribe as l, takeWhile as p, onEnd as h } from "wonka";

var y = {};

var x = t(y);

var g = x.Provider;

var b = x.Consumer;

x.displayName = "UrqlContext";

var useClient = () => {
  var e = n(x);
  if (e === y && "production" !== process.env.NODE_ENV) {
    var r = "No client has been specified using urql's Provider. please create a client and add a Provider.";
    console.error(r);
    throw new Error(r);
  }
  return e;
};

var q = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};

var areOperationsEqual = (e, r) => e === r || !(!e || !r || e.key !== r.key);

var computeNextState = (e, r) => {
  var t = {
    ...e,
    ...r,
    data: void 0 !== r.data || r.error ? r.data : e.data,
    fetching: !!r.fetching,
    stale: !!r.stale
  };
  return ((e, r) => {
    for (var t in e) {
      if (!(t in r)) {
        return !0;
      }
    }
    for (var n in r) {
      if ("operation" === n ? !areOperationsEqual(e[n], r[n]) : e[n] !== r[n]) {
        return !0;
      }
    }
    return !1;
  })(e, t) ? t : e;
};

var hasDepsChanged = (e, r) => {
  for (var t = 0, n = r.length; t < n; t++) {
    if (e[t] !== r[t]) {
      return !0;
    }
  }
  return !1;
};

var _ = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function deferDispatch(e, r) {
  if ("production" !== process.env.NODE_ENV && _ && _.ReactCurrentOwner && _.ReactCurrentOwner.current) {
    Promise.resolve(r).then(e);
  } else {
    e(r);
  }
}

function useMutation(r) {
  var t = a(!0);
  var n = useClient();
  var [s, l] = u(q);
  var p = i(((a, u) => {
    deferDispatch(l, {
      ...q,
      fetching: !0
    });
    return c(v(1)(f((e => !e.hasNext))(d((e => {
      if (t.current) {
        deferDispatch(l, {
          fetching: !1,
          stale: e.stale,
          data: e.data,
          error: e.error,
          extensions: e.extensions,
          operation: e.operation
        });
      }
    }))(n.executeMutation(e(r, a), u || {})))));
  }), [ n, r, l ]);
  o((() => {
    t.current = !0;
    return () => {
      t.current = !1;
    };
  }), []);
  return [ s, p ];
}

function useRequest(r, t) {
  var n = a(void 0);
  return s((() => {
    var a = e(r, t);
    if (void 0 !== n.current && n.current.key === a.key) {
      return n.current;
    } else {
      n.current = a;
      return a;
    }
  }), [ r, t ]);
}

var getCacheForClient = e => {
  if (!e._react) {
    var r = new Set;
    var t = new Map;
    if (e.operations$) {
      l((e => {
        if ("teardown" === e.kind && r.has(e.key)) {
          r.delete(e.key);
          t.delete(e.key);
        }
      }))(e.operations$);
    }
    e._react = {
      get: e => t.get(e),
      set(e, n) {
        r.delete(e);
        t.set(e, n);
      },
      dispose(e) {
        r.add(e);
      }
    };
  }
  return e._react;
};

var isSuspense = (e, r) => e.suspense && (!r || !1 !== r.suspense);

function useQuery(e) {
  var r = useClient();
  var t = getCacheForClient(r);
  var n = isSuspense(r, e.context);
  var a = useRequest(e.query, e.variables);
  var c = s((() => {
    if (e.pause) {
      return null;
    }
    var u = r.executeQuery(a, {
      requestPolicy: e.requestPolicy,
      ...e.context
    });
    return n ? d((e => {
      t.set(a.key, e);
    }))(u) : u;
  }), [ t, r, a, n, e.pause, e.requestPolicy, e.context ]);
  var v = i(((e, r) => {
    if (!e) {
      return {
        fetching: !1
      };
    }
    var n = t.get(a.key);
    if (!n) {
      var u;
      var i = l((e => {
        n = e;
        if (u) {
          u(n);
        }
      }))(p((() => r && !u || !n))(e));
      if (null == n && r) {
        var o = new Promise((e => {
          u = e;
        }));
        t.set(a.key, o);
        throw o;
      } else {
        i.unsubscribe();
      }
    } else if (r && null != n && "then" in n) {
      throw n;
    }
    return n || {
      fetching: !0
    };
  }), [ t, a ]);
  var f = [ r, a, e.requestPolicy, e.context, e.pause ];
  var [y, x] = u((() => [ c, computeNextState(q, v(c, n)), f ]));
  var g = y[1];
  if (c !== y[0] && hasDepsChanged(y[2], f)) {
    x([ c, g = computeNextState(y[1], v(c, n)), f ]);
  }
  o((() => {
    var e = y[0];
    var r = y[2][1];
    var n = !1;
    var updateResult = e => {
      n = !0;
      deferDispatch(x, (r => {
        var t = computeNextState(r[1], e);
        return r[1] !== t ? [ r[0], t, r[2] ] : r;
      }));
    };
    if (e) {
      var a = l(updateResult)(h((() => {
        updateResult({
          fetching: !1
        });
      }))(e));
      if (!n) {
        updateResult({
          fetching: !0
        });
      }
      return () => {
        t.dispose(r.key);
        a.unsubscribe();
      };
    } else {
      updateResult({
        fetching: !1
      });
    }
  }), [ t, y[0], y[2][1] ]);
  var b = i((u => {
    var i = {
      requestPolicy: e.requestPolicy,
      ...e.context,
      ...u
    };
    deferDispatch(x, (e => [ n ? d((e => {
      t.set(a.key, e);
    }))(r.executeQuery(a, i)) : r.executeQuery(a, i), e[1], f ]));
  }), [ r, t, a, n, v, e.requestPolicy, e.context ]);
  return [ g, b ];
}

function useSubscription(e, r) {
  var t = useClient();
  var n = useRequest(e.query, e.variables);
  var c = a(r);
  c.current = r;
  var v = s((() => !e.pause ? t.executeSubscription(n, e.context) : null), [ t, n, e.pause, e.context ]);
  var f = [ t, n, e.context, e.pause ];
  var [d, p] = u((() => [ v, {
    ...q,
    fetching: !!v
  }, f ]));
  var y = d[1];
  if (v !== d[0] && hasDepsChanged(d[2], f)) {
    p([ v, y = computeNextState(d[1], {
      fetching: !!v
    }), f ]);
  }
  o((() => {
    var updateResult = e => {
      deferDispatch(p, (r => {
        var t = computeNextState(r[1], e);
        if (r[1] === t) {
          return r;
        }
        if (c.current && r[1].data !== t.data) {
          t.data = c.current(r[1].data, t.data);
        }
        return [ r[0], t, r[2] ];
      }));
    };
    if (d[0]) {
      return l(updateResult)(h((() => {
        updateResult({
          fetching: !!v
        });
      }))(d[0])).unsubscribe;
    } else {
      updateResult({
        fetching: !1
      });
    }
  }), [ d[0] ]);
  var x = i((r => {
    var a = t.executeSubscription(n, {
      ...e.context,
      ...r
    });
    deferDispatch(p, (e => [ a, e[1], f ]));
  }), [ t, e.context, n ]);
  return [ y, x ];
}

function Mutation(e) {
  var r = useMutation(e.query);
  return e.children({
    ...r[0],
    executeMutation: r[1]
  });
}

function Query(e) {
  var r = useQuery(e);
  return e.children({
    ...r[0],
    executeQuery: r[1]
  });
}

function Subscription(e) {
  var r = useSubscription(e, e.handler);
  return e.children({
    ...r[0],
    executeSubscription: r[1]
  });
}

export { b as Consumer, x as Context, Mutation, g as Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql.es.js.map
