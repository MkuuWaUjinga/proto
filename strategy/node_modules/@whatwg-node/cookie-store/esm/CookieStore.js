import { EventTarget } from '@whatwg-node/events';
import { CookieChangeEvent } from './CookieChangeEvent.js';
import { parse } from './parse.js';
export class CookieStore extends EventTarget {
    get [Symbol.toStringTag]() {
        return 'CookieStore';
    }
    constructor(cookieString) {
        super();
        this.cookieMap = new Map();
        this.cookieMap = parse(cookieString);
    }
    async get(init) {
        if (init == null) {
            throw new TypeError('CookieStoreGetOptions must not be empty');
        }
        else if (init instanceof Object && !Object.keys(init).length) {
            throw new TypeError('CookieStoreGetOptions must not be empty');
        }
        return (await this.getAll(init))[0];
    }
    async set(init, possibleValue) {
        var _a, _b, _c;
        const item = {
            name: '',
            value: '',
            path: '/',
            secure: false,
            sameSite: 'strict',
            expires: null,
            domain: null,
        };
        if (typeof init === 'string') {
            item.name = init;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            item.value = possibleValue;
        }
        else {
            Object.assign(item, init);
            if (item.path && !item.path.startsWith('/')) {
                throw new TypeError('Cookie path must start with "/"');
            }
            if ((_a = item.domain) === null || _a === void 0 ? void 0 : _a.startsWith('.')) {
                throw new TypeError('Cookie domain cannot start with "."');
            }
            if (((_b = item.name) === null || _b === void 0 ? void 0 : _b.startsWith('__Host')) && item.domain) {
                throw new TypeError('Cookie domain must not be specified for host cookies');
            }
            if (((_c = item.name) === null || _c === void 0 ? void 0 : _c.startsWith('__Host')) && item.path !== '/') {
                throw new TypeError('Cookie path must not be specified for host cookies');
            }
            if (item.path && item.path.endsWith('/')) {
                item.path = item.path.slice(0, -1);
            }
            if (item.path === '') {
                item.path = '/';
            }
        }
        if (item.name === '' && item.value && item.value.includes('=')) {
            throw new TypeError("Cookie value cannot contain '=' if the name is empty");
        }
        if (item.name && item.name.startsWith('__Host')) {
            item.secure = true;
        }
        const previousCookie = await this.get(item);
        this.cookieMap.set(item.name || '', item);
        if (this.onchange) {
            const changed = [];
            const deleted = [];
            if (previousCookie && !(await this.get(item))) {
                deleted.push({ ...item, value: undefined });
            }
            else {
                changed.push(item);
            }
            const event = new CookieChangeEvent('change', { changed, deleted });
            this.onchange(event);
        }
    }
    async getAll(init) {
        const cookies = Array.from(this.cookieMap.values());
        if (init == null || Object.keys(init).length === 0) {
            return cookies;
        }
        let name;
        if (typeof init === 'string') {
            name = init;
        }
        else {
            name = init.name;
        }
        return cookies.filter(cookie => cookie.name === name);
    }
    async delete(init) {
        const item = {
            name: '',
            value: '',
            path: '/',
            secure: false,
            sameSite: 'strict',
            expires: null,
            domain: null,
        };
        if (typeof init === 'string') {
            item.name = init;
        }
        else {
            Object.assign(item, init);
        }
        item.expires = 0;
        await this.set(item);
    }
    get cookieString() {
        const cookieStrings = [];
        for (const [, item] of this.cookieMap) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            let cookieString = `${item.name}=${encodeURIComponent(item.value)}`;
            if (item.domain) {
                cookieString += '; Domain=' + item.domain;
            }
            if (item.path) {
                cookieString += '; Path=' + item.path;
            }
            if (typeof item.expires === 'number') {
                cookieString += '; Expires=' + new Date(item.expires).toUTCString();
            }
            if ((item.name && item.name.startsWith('__Secure')) || item.secure) {
                item.sameSite = 'lax';
                cookieString += '; Secure';
            }
            switch (item.sameSite) {
                case 'lax':
                    cookieString += '; SameSite=Lax';
                    break;
                case 'strict':
                    cookieString += '; SameSite=Strict';
                    break;
                case 'none':
                    cookieString += '; SameSite=None';
                    break;
            }
            cookieStrings.push(cookieString);
        }
        return cookieStrings.join('; ');
    }
    set cookieString(cookieString) {
        this.cookieMap = parse(cookieString);
    }
}
